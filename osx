#!/usr/bin/env bash
#
#                        _ _
#   ___  _____  __   ___| (_)
#  / _ \/ __\ \/ /  / __| | |
# | (_) \__ \>  <  | (__| | |
#  \___/|___/_/\_\  \___|_|_|
#
# Shortcuts for OS X operations.
#
# Copyright (c) 2015 William Melody • hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

# Treat unset variables and parameters other than the special parameters ‘@’ or
# ‘*’ as an error when performing parameter expansion. An 'unbound variable'
# error message will be written to the standard error, and a non-interactive
# shell will exit.
#
# This requires using parameter expansion to test for unset variables.
#
# http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
#
# The two approaches that are probably the most appropriate are:
#
# ${parameter:-word}
#   If parameter is unset or null, the expansion of word is substituted.
#   Otherwise, the value of parameter is substituted. In other words, "word"
#   acts as a default value when the value of "$parameter" is blank. If "word"
#   is not present, then the default is blank (essentially an empty string).
#
# ${parameter:?word}
#   If parameter is null or unset, the expansion of word (or a message to that
#   effect if word is not present) is written to the standard error and the
#   shell, if it is not interactive, exits. Otherwise, the value of parameter
#   is substituted.
#
# Examples
# ========
#
# Arrays:
#
#   ${some_array[@]:-}              # blank default value
#   ${some_array[*]:-}              # blank default value
#   ${some_array[0]:-}              # blank default value
#   ${some_array[0]:-default_value} # default value: the string 'default_value'
#
# Positional variables:
#
#   ${1:-alternative} # default value: the string 'alternative'
#   ${2:-}            # blank default value
#
# With an error message:
#
#   ${1:?'error message'}  # exit with 'error message' if variable is unbound
#
# Short form: set -u
set -o nounset

# Exit immediately if a pipeline returns non-zero.
#
# NOTE: this has issues. When using read -rd '' with a heredoc, the exit
# status is non-zero, even though there isn't an error, and this setting
# then causes the script to exit. read -rd '' is synonymous to read -d $'\0',
# which means read until it finds a NUL byte, but it reaches the EOF (end of
# heredoc) without finding one and exits with a 1 status. Therefore, when
# reading from heredocs with set -e, there are three potential solutions:
#
# Solution 1. set +e / set -e again:
#
# set +e
# read -rd '' variable <<EOF
# EOF
# set -e
#
# Solution 2. <<EOF || true:
#
# read -rd '' variable <<EOF || true
# EOF
#
# Solution 3. Don't use set -e or set -o errexit at all.
#
# More information:
#
# https://www.mail-archive.com/bug-bash@gnu.org/msg12170.html
#
# Short form: set -e
set -o errexit

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set IFS to just newline and tab at the start
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
#
# $DEFAULT_IFS and $SAFER_IFS
#
# $DEFAULT_IFS contains the default $IFS value in case it's needed, such as
# when expanding an array and you want to separate elements by spaces.
# $SAFER_IFS contains the preferred settings for the program, and setting it
# separately makes it easier to switch between the two if needed.
DEFAULT_IFS="$IFS"
SAFER_IFS=$'\n\t'
IFS="$SAFER_IFS"

###############################################################################
# Globals
###############################################################################

_VERSION="0.1.0-alpha"

# DEFAULT_COMMAND
#
# The command to be run by default, when no command name is specified. If the
# environment has an existing $DEFAULT_COMMAND set, then that value is used.
DEFAULT_COMMAND="${DEFAULT_COMMAND:-help}"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  "
    "$@"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "❌  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "$@"
}

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
_RAW_OPTIONS="$*"

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
#
# In this example, `-x` and `-h` are regular short options, while `o` is
# assumed to have an argument and will be split if joined with the string,
# meaning `-oARG` would be split to `-o ARG`.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#))
do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-$c")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("$@")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("$1")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize $_COMMAND_ARGV array
#
# This array contains all of the arguments that get passed along to each
# command. This is essentially the same as the program arguments, minus those
# that have been filtered out in the program option parsing loop. This array
# is initialized with $0, which is the program's name.
_COMMAND_ARGV=("$0")
# Initialize $_CMD and `$_USE_DEBUG`, which can continue to be blank depending
# on what the program needs.
_CMD=""
_USE_DEBUG=0

while [ $# -gt 0 ]
do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      _CMD="help"
      ;;
    --version)
      _CMD="version"
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    *)
      # The first non-option argument is assumed to be the command name.
      # All subsequent arguments are added to $_COMMAND_ARGV.
      if [[ -n $_CMD ]]
      then
        _COMMAND_ARGV+=("$opt")
      else
        _CMD="$opt"
      fi
      ;;
  esac
done

# Set $_COMMAND_PARAMETERS to $_COMMAND_ARGV, minus the initial element, $0. This
# provides an array that is equivalent to $* and $@ within each command
# function, though the array is zero-indexed, which could lead to confusion.
_COMMAND_PARAMETERS=("${_COMMAND_ARGV[@]:1}")

_debug printf "\$_CMD: %s\n" "$_CMD"
_debug printf "\$_RAW_OPTIONS (one per line):\n%s\n" "$_RAW_OPTIONS"
_debug printf "\$_COMMAND_ARGV: %s\n" "${_COMMAND_ARGV[*]}"
_debug printf "\$_COMMAND_PARAMETERS: %s\n" "${_COMMAND_PARAMETERS[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_ME
#
# Set to the program's basename.
_ME=$(basename "$0")

_debug printf "\$_ME: %s\n" "$_ME"

###############################################################################
# Load Commands
###############################################################################

# Initialize $_DEFINED_COMMANDS array.
_DEFINED_COMMANDS=()

# _load_commands()
#
# Usage:
#   _load_commands
#
# Loads all of the commands sourced in the environment.
_load_commands() {

  _debug printf "_load_commands(): entering...\n"
  _debug printf "_load_commands() declare -F:\n%s\n" "$(declare -F)"

  # declare is a bash built-in shell function that, when called with the '-F'
  # option, displays all of the functions with the format
  # `declare -f function_name`. These are then assigned as elements in the
  # $function_list array.
  local function_list=($(declare -F))

  for c in "${function_list[@]}"
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local function_name
    function_name=$(printf "%s" "$c" | awk '{ print $3 }')

    _debug printf "_load_commands() \$function_name: %s\n" "$function_name"

    # Add the function name to the $_DEFINED_COMMANDS array unless it starts
    # with an underscore or is one of the desc(), debug(), or die() functions,
    # since these are treated as having 'private' visibility.
    if ! ( [[ "$function_name" =~ ^_(.*)  ]] || \
           [[ "$function_name" == "desc"  ]] || \
           [[ "$function_name" == "debug" ]] || \
           [[ "$function_name" == "die"   ]]
    )
    then
      _DEFINED_COMMANDS+=("$function_name")
    fi
  done

  _debug printf \
    "commands() \$_DEFINED_COMMANDS:\n%s\n" \
    "${_DEFINED_COMMANDS[*]:-}"
}

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  _debug printf "main(): entering...\n"
  _debug printf "main() \$_CMD (upon entering): %s\n" "$_CMD"

  # If $_CMD is blank, then set to `$DEFAULT_COMMAND`
  if [[ -z $_CMD ]]
  then
    _CMD="$DEFAULT_COMMAND"
  fi

  # Load all of the commands.
  _load_commands

  # If the command is defined, run it, otherwise return an error.
  if _contains "$_CMD" "${_DEFINED_COMMANDS[*]:-}"
  then
    # Pass all comment arguments to the program except for the first ($0).
    $_CMD "${_COMMAND_PARAMETERS[@]:-}"
  else
    _die printf "Unknown command: %s\n" "$_CMD"
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _function_exists()
#
# Usage:
#   _function_exists "possible_function_name"
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "$1" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Takes an item and a list and determines whether the list contains the item.
_contains() {
  local test_list=(${*:2})
  for _test_element in "${test_list[@]:-}"
  do
    _debug printf "_contains() \$_test_element: %s\n" "$_test_element"
    if [[ "$_test_element" == "$1" ]]
    then
      _debug printf "_contains() match: %s\n" "$1"
      return 0
    fi
  done
  return 1
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Takes a separator and a list of items, joining that list of items with the
# separator.
_join() {
  local separator
  local target_array
  local dirty
  local clean
  separator="$1"
  target_array=(${@:2})
  dirty="$(printf "${separator}%s"  "${target_array[@]}")"
  clean="${dirty:${#separator}}"
  printf "%s" "${clean}"
}

# _command_argv_includes()
#
# Usage:
#   _command_argv_includes "an_argument"
#
# Takes a possible command argument and determines whether it is included in
# the command argument list.
#
# This is a shortcut for simple cases where a command wants to check for the
# presence of options quickly without parsing the options again.
_command_argv_includes() {
  _contains "$1" "${_COMMAND_ARGV[*]}"
}

# _blank()
#
# Usage:
#   _blank "$an_argument"
#
# Takes an argument and returns true if it is blank.
_blank() {
  [[ -z "${1:-}" ]]
}

# _present()
#
# Usage:
#   _present "$an_argument"
#
# Takes an argument and returns true if it is present.
_present() {
  [[ -n "${1:-}" ]]
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'EOM'
# some message
# EOM
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z $1 ]] && _die printf "desc: No command name specified.\n"
  if [[ -n ${2:-} ]]
  then
    read -d '' "_desc_$1" <<EOM
$2
EOM
    _debug printf "desc() set with argument: _desc_%s\n" "$1"
  else
    read -d '' "_desc_$1"
    _debug printf "desc() set with pipe: _desc_%s\n" "$1"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  local var="_desc_$1"
  if [[ -n ${!var:-} ]]
  then
    printf "%s\n" "${!var}"
  else
    printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc "version" <<EOM
Usage:
  $_ME ( version | --version )

Description:
  Display the current program version.

  To save you the trouble, the current version is $_VERSION
EOM
version() {
  printf "%s\n" "$_VERSION"
}

# Help ########################################################################

desc "help" <<EOM
Usage:
  $_ME help [<command>]

Description:
  Display help information for $_ME or a specified command.
EOM
help() {
  if [[ ${#_COMMAND_ARGV[@]} = 1 ]]
  then
    cat <<EOM
                       _ _
  ___  _____  __   ___| (_)
 / _ \\/ __\\ \\/ /  / __| | |
| (_) \\__ \\>  <  | (__| | |
 \\___/|___/_/\\_\\  \\___|_|_|

Shortcuts for OS X operations.

Version: $_VERSION

Usage:
  $_ME <command> [--command-options] [<arguments>]
  $_ME -h | --help
  $_ME --version

Options:
  -h --help  Display this help information.
  --version  Display version information.

Help:
  $_ME help [<command>]

$(commands)
EOM
  else
    _print_desc "$1"
  fi
}

# Command List ################################################################

desc "commands" <<EOM
Usage:
  $_ME commands [--raw]

Options:
  --raw  Display the command list without formatting.

Description:
  Display the list of available commands.
EOM
commands() {
  if _command_argv_includes "--raw"
  then
    printf "%s\n" "${_DEFINED_COMMANDS[@]}"
  else
    printf "Available commands:\n"
    printf "  %s\n" "${_DEFINED_COMMANDS[@]}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""   - Optional. A short description for the command.
# example() { : }   - The command called by the user.
#
#
# desc example <<EOM
#   Example help text. Options specified with http://docopt.org/
# EOM
# example() {
#   echo "Hello, World!"
# }
#
###############################################################################

# -------------------------------------------------------------------- Accounts

desc "accounts" <<EOM
Usage:
  $_ME accounts (list | login <username> | window)

Subcommands:
  list    List login user accounts.
  login   Login as the specified user, aka "Fast User Switching."
  window  Go to the OS X login window.
EOM
_USER_MENU="/System/Library/CoreServices/Menu Extras/User.menu"
_CGSESSION="${_USER_MENU}/Contents/Resources/CGSession"
accounts() {
  _debug printf "accounts() >> start\n"

  local _subcommand="help"
  local _arguments=()

  for arg in "${_COMMAND_ARGV[@]:-}"
  do
    case $arg in
      list|login|window)
        _subcommand="$arg"
        ;;
      *)
        _arguments+=($arg)
        ;;
    esac
  done


  case "$_subcommand" in
    "list")
      local _users_and_ids=($(dscl . list /Users uid | grep -v '^_'))
      for _user in "${_users_and_ids[@]}"
      do
        local _username="$(echo "$_user" | awk '{print $1}')"

        # Only print users with valid home directories, which is used here as
        # an indication that the account is a valid login account. So far I've
        # been unable to find a better way to list only full login user
        # accounts.
        local _home_directory="$(
          dscl . -read "/Users/${_username}" NFSHomeDirectory | \
            awk '{for (i=2; i<NF; i++) printf $i " "; print $NF}'
        )"
        _debug printf "accounts() \$_username: %s\n" "$_username"
        _debug printf "accounts() \$_home_directory: %s\n" "$_home_directory"
        if ! ( [[ "$_username" == "root" ]]         ||
               [[ "$_username" == "daemon" ]]       ||
               [[ "$_home_directory" =~ ^/var.* ]]  ||
               [[ "$_home_directory" =~ ^/dev.* ]]  ||
               [[ "$_home_directory" =~ ^/opt.* ]]
        )
        then
          echo "$_username"
        fi
      done
      ;;
    "login")
      local _user="${_ARGUMENTS[1]:-}"
      if [[ -z "$_user" ]]
      then
        _die printf "User missing.\n%s\n" "$(_print_help)"
      fi

      local _user_id=$(id -u "$_user")
      if [[ -z "$_user_id" ]]
      then
        _die printf "No user with that name found.\n"
      fi

      _debug printf "%s\n" "$_CGSESSION -switchToUserID $_user_id"
      "$_CGSESSION" -switchToUserID "$_user_id"
      ;;
    "window")
      "$_CGSESSION" -suspend
      ;;
    "help")
      $_ME help accounts
      ;;
  esac
}

# --------------------------------------------------------------------- Airport

desc airport <<EOM
Usage:
  $_ME airport (on | off | info | quality | scan | join <SSID>)

Subcommands:
  on       Turn wireless on.
  off      Turn wireless off.
  info     Show the current airport status.
  quality  Show the wireless quality as a percentage.
  scan     Perform a scan for wireless networks.
  join     Join the specified network.
EOM
_AIRPORT_FRAMEWORK_PATH="/System/Library/PrivateFrameworks/Apple80211.framework"
_AIRPORT_CMD="${_AIRPORT_FRAMEWORK_PATH}/Versions/A/Resources/airport"
airport() {
  local _networksetup_cmd="$(which networksetup)"
  local _subcommand="info"
  local _arguments=()

  # Command references:
  # - http://apple.stackexchange.com/a/90516
  # - https://jamfnation.jamfsoftware.com/discussion.html?id=4849
  local _wifi_interface="$(
    "$_networksetup_cmd" \
      -listallhardwareports | awk '/Wi-Fi|AirPort/ {getline; print $NF}'
  )"

  for arg in "${_COMMAND_ARGV[@]:-}"
  do
    case $arg in
      on|off|info|quality|scan|join)
        _subcommand="$arg"
        ;;
      *)
        _arguments+=($arg)
        ;;
    esac
  done

  case "$_subcommand" in
    "on")
      "$_networksetup_cmd" -setairportpower "$_wifi_interface" on && \
        printf "Airport on\n"
      ;;
    "off")
      "$_networksetup_cmd" -setairportpower "$_wifi_interface" off && \
        printf "Airport off\n"
      ;;
    "join")
      local _ssid="${_arguments[1]:-}"
      local _password=

      # Request password without displaying it
      printf "Password: "
      read -s _password
      printf "\n" # print newline to stop `read`.

      _debug printf "airport() \$_wifi_interface: %s\n" "$_wifi_interface"
      _debug printf "airport() \$_ssid: %s\n" "${_ssid}"

      "$_networksetup_cmd" \
        -setairportnetwork \
        "$_wifi_interface" \
        "$_ssid" \
        "$_password"
      ;;
    "info")
      "$_AIRPORT_CMD" --getinfo
      ;;
    "quality")
      # Reference: http://apple.stackexchange.com/a/110884
      local _info="$($_ME airport info)"
      local _signal="$(
        printf "%s\n" "$_info" | awk '/agrCtlRSSI/ {print $NF}'
      )"
      local _noise="$(
        printf "%s\n" "$_info" | awk '/agrCtlNoise/ {print $NF}'
      )"
      local _snr="$(printf "100*(%s -(%s))\n" "$_signal" "$_noise" | bc -l)"
      local _percent="$(printf "%s/50\n" "$_snr" | bc -l)"
      printf "%s%%\n" "${_percent%.*}"
      ;;
    "scan")
      "$_AIRPORT_CMD" --scan
      ;;
  esac
}

# ----------------------------------------------------------------------- Audio

desc play <<EOM
Alias for \`afplay\`
$(printf "%s\n" "$(afplay -h 2>&1)" | sed s/afplay/"$_ME"\ play/g)
EOM
play() {
  afplay "$*"
}

desc volume <<EOM
Usage:
  $_ME volume (  <0-9> | <00-100> | mute | unmute )

Arguments:
  <none>    Print the current output volume level as a percent.
  <0-9>     Set the output volume to about the nearest tenth percent. Sometimes
            the actual number is slightly off for reasons unknown.
  <00-100>  Set the output volume to the specified percent.
  mute      Mute output.
  unmute    Unmute output.
EOM
_print_mute_state() {
  local _mute_state=$(osascript -e "output muted of (get volume settings)")
  printf "Mute: %s\n" "${_mute_state}"
}
_print_current_output_volume() {
  local _volume=$(osascript -e "output volume of (get volume settings)")
  printf "Output volume: %s%%\n" "${_volume}"
}
volume() {
  case "${1}" in
    mute)
      osascript -e "set volume output muted true"
      _print_mute_state
      ;;
    unmute)
      osascript -e "set volume output muted false"
      _print_mute_state
      ;;
    *[0-9][0-9])
      osascript -e "set volume output volume ${1}"
      _print_current_output_volume
      ;;
    [0-9])
      osascript -e "set volume output volume ${1}0"
      _print_current_output_volume
      ;;
    *)
      _print_current_output_volume
      _print_mute_state
      ;;
  esac
}
desc vol <<EOM
Description:
  Volume controls. This is an alias for the \`volume\`
  command. See \`help volume\` for usage information.
EOM
vol() {
  $_ME volume "$@"
}

# --------------------------------------------------------------------- battery

desc battery <<EOM
Usage:
  $_ME battery [-l|--long]
  $_ME battery status [-l|--long]
  $_ME battery cycles
  $_ME battery health

Subcommands:
  status  Current battery status.
  cycles  Number of battery cycles.
  health  Health of the battery, using the current maximum capacity as perctage
          of the battery's design capacity).

Options:
  -l --long  Print longform information about the battery status.

Description:
  Print battery info. When no subcommand is specified, display \`status\`.
EOM
# _ioreg_property()
#
# Usage:
#   _ioreg_property <object name> <property key>
#
# Description:
#   Print individual Darwin / OS X I/O Kit Registry property keys via the
#   `ioreg` tool.
#
# Example:
#   _ioreg_property AppleSmartBattery CycleCount
_ioreg_property() {
  local _name="${1:-}"
  if [[ -z "$_name" ]]
  then
    printf "_ioreg_property(): No object name specified.\n"
    exit 1
  fi
  local _key="${2:-}"
  if [[ -z "$_key" ]]
  then
    printf "_ioreg_property(): No property key specified.\n"
    exit 1
  fi
  local _value
  _value="$(ioreg \
    -l \
    -n "$_name" \
    -r | awk -v pattern="\"${_key}\"" '$1 == pattern {print $3}')"
  printf "%s\n" "$_value"
}
battery() {
  local _long_status=
  local _subcommand="status"
  for arg in "${_COMMAND_ARGV[@]:-}"
  do
    case $arg in
      -l|--long)
        _long_status=1
        ;;
      status|cycles|health)
        _subcommand="$arg"
        ;;
      *)
        arguments+=($arg)
        ;;
    esac
  done

  case "$_subcommand" in
    "status")
      if [[ -n "$_long_status" ]]
      then
        ioreg -l -w 0 -n AppleSmartBattery -r
      else
        pmset -g batt
      fi
      ;;
    "cycles")
      _ioreg_property AppleSmartBattery CycleCount
      ;;
    "health")
      local _health_percentage
      _health_percentage="$(ioreg -l -n AppleSmartBattery -r | \
        awk '/MaxCapacity/{mc=$3};/DesignCapacity/{dc=$3};END{print 100*mc/dc}'
      )"
      printf "%s%%\n" "$_health_percentage"
      ;;
  esac
}

# ------------------------------------------------------------------ caffeinate

desc caffeinate <<EOM
Usage:
  $_ME caffeinate [-disu] [-t timeout] [command] [arguments]

Description:
  Prevent the system from sleeping on behalf of a utility.

  This is simply a bookmark for the caffeinate command.

  See \`man caffeinate\` for more information.

Examples:
  caffeinate -u -t 3600
    Prevent sleeping for one hour (3,600 seconds).

  caffeinate -s scp bigfile me:myserver/bigfile
    Prevent sleeping until the secure file copy (scp) completes.
EOM
_CAFFEINATE_CMD="$(which caffeinate)"
caffeinate() {
  "$_CAFFEINATE_CMD" "$*"
}

# --------------------------------------------------------------------- desktop

desc desktop <<EOM
Usage:
  $_ME desktop ( hide | show )

Description:
  Hide/show all desktop icons (useful when presenting).
EOM
desktop() {
  local _action="$1"
  case "$_action" in
    hide)
      defaults write com.apple.finder CreateDesktop -bool false && \
        killall Finder
      ;;
    show)
      defaults write com.apple.finder CreateDesktop -bool true && \
        killall Finder
      ;;
    *)
      _print_desc "desktop"
      ;;
  esac
}

# ------------------------------------------------------------------------- DNS

desc flushdns <<EOM
Usage:
  $_ME flushdns

Description:
  Flush Directory Service cache.
EOM
flushdns() {
  # pre-yosemite
  # need os x version checking to use properly
  #dscacheutil -flushcache && killall -HUP mDNSResponder
  sudo discoveryutil mdnsflushcache && sudo discoveryutil udnsflushcaches
}

# ------------------------------------------------------------------------ fans

desc fans <<EOM
Usage:
  $_ME fans

Description:
  Display fan stats via the iStats Ruby gem.

  More information:
    https://github.com/Chris911/iStats
EOM
fans() {
  if _command_exists "istats"
  then
    istats fan
  else
    _die printf "\
iStats not installed.

Install via Rubygems with:
  gem install iStats

More information:
  https://github.com/Chris911/iStats
"
  fi
}

# ---------------------------------------------------------------------- Finder

desc clean_ds_store <<EOM
Usage:
  $_ME clean_ds_store

Description:
  Recursively delete \`.DS_Store\` files
EOM
clean_ds_store() {
  find . -type f -name '*.DS_Store' -ls -delete
}

desc finder <<EOM
Usage:
  $_ME finder hidden ( hide | show )

Description:
  Hide/show hidden files in the Finder.
EOM
finder() {
  local _target="$1"
  local _action="$2"
  if [[ "$_target" != "hidden" ]]
  then
    _print_desc "finder"
    exit 1
  fi
  case "$_action" in
    hide)
      defaults write com.apple.finder AppleShowAllFiles -bool false && \
        killall Finder
      ;;
    show)
      defaults write com.apple.finder AppleShowAllFiles -bool true && \
        killall Finder
      ;;
    *)
      _print_desc "finder"
      ;;
  esac
}

# --------------------------------------------------------------------- hdiutil

desc eject <<EOM
Usage:
  $_ME eject <volname>

Description:
  Ejects a given volume (eg, a disk image).
EOM
eject() {
  if [[ -z "$1" ]]
  then
    _die _print_desc "eject"
  fi
  hdiutil eject "/Volumes/$*"
}

# ------------------------------------------------------------------ JavaScript

desc jsc <<EOM
Usage:
  $_ME jsc [<filename.js>]

Description:
  Run the JavaScriptCore.framework jsc REPL.

  If no argument is provided, launch an interactive REPL session. If a
  filename is provided as the second argument, run that file with jsc.
EOM
jsc() {
  local _jscbin="/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc"
  if [[ -e "$_jscbin" ]]
  then
    local _javascript_filename="$1"
    if [[ -z "$_javascript_filename" ]]
    then
      "$_jscbin"
    else
      _debug printf "jsc() \$_javascript_filename: %s\n" "$_javascript_filename"
      "$_jscbin" "$_javascript_filename"
    fi
  else
    printf "JavaScriptCore.framework not found.\n"
  fi
}

# -------------------------------------------------------------- LaunchServices

desc launch_services <<EOM
Usage:
  $_ME launch_services cleanup

Description:
  Clean up LaunchServices to remove duplicates in the "Open With" menu.
EOM
launch_services() {
  local _cmd_path="/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister"
  local _action="$1"

  case "$_action" in
    "cleanup")
      "$_cmd_path" -kill -r -domain local -domain system -domain user && \
        killall Finder
      ;;
    *)
      _print_desc "launch_services"
      ;;
  esac
}

# ---------------------------------------------------------------------- Locate

desc locate <<EOM
Usage:
  $_ME locate updatedb

Description:
  Update the locate database.

  NOTE: prefer using \`spotlight\` commands rather than \`locate\`.
EOM
locate() {
  local _action="$1"
  case "$_action" in
    "updatedb")
      sudo /usr/libexec/locate.updatedb
      ;;
    *)
      _print_desc "locate"
      ;;
  esac
}


# ------------------------------------------------------------------------ lock

desc afk <<EOM
Alias for \`$_ME lock\`

For full usage information, run:
  $_ME help lock
EOM
afk() {
  lock "$*"
}

desc lock <<EOM
Usage:
  $_ME lock

Description:
  Lock the screen (when going AFK).
EOM
lock() {
  "/System/Library/CoreServices/Menu Extras/User.menu/Contents/Resources/CGSession" -suspend
}

# ---------------------------------------------------------------- networksetup

desc networksetup <<EOM
Usage:
  $_ME networksetup <arguments>

Description:
  Configuration tool for network settings in System Preferences.

  This is simply a bookmark for the networksetup utility.

  See \`man networksetup\` for more information.

Examples:
   networksetup -listallnetworkservices

   networksetup -setmanual "Built-in Ethernet" 192.168.100.100 255.255.255.0
   192.168.100.1

   networksetup -setdnsservers "Built-in Ethernet" 192.168.100.100
   192.168.100.12

   networksetup -setsearchdomains "Built-in Ethernet" company.com corp.com

   networksetup -setwebproxy "Built-in Ethernet" proxy.company.com 80

   networksetup -setwebproxy "Built-In Ethernet" proxy.company.com 80 On
   authusername authpassword

   networksetup -duplicatenetworkservice "Built-In Ethernet" "Local LAN"

   networksetup -getdnsservers "Built-In Ethernet"

   networksetup -setMTU en0 1500

   networksetup -setMedia en0 autoselect

   networksetup -setMedia en0 100baseTX half-duplex

   networksetup -createBond MyBond en0 en1

   networksetup -addDeviceToBond en0 bond0

   networksetup -setpppoepassword MyPPPoE - < ~/Desktop/MyPasswordFile.txt

   networksetup -createlocation Home populate
EOM
_NETWORKSETUP_CMD="$(which networksetup)"
networksetup() {
  "$_NETWORKSETUP_CMD" "$*"
}

# ----------------------------------------------------------------- Preferences

desc plistbuddy <<EOM
Usage:
  $_ME plistbuddy <PlistBuddy arguments> [<PlistBuddy options>]

Description:
  PlistBuddy alias, because sometimes \`defaults\` just doesn’t cut it.
EOM
plistbuddy() {
  /usr/libexec/PlistBuddy "$@"
}

# --------------------------------------------------------------------- process

desc process <<EOM
Usage:
  $_ME process pause ( <pid> | -n --name <name> )
  $_ME process continue ( <pid> | -n --name <name> )
  $_ME process throttle <pid> <max usage>
  $_ME process kill ( <pid> | -n --name <name> )

Description:
  Pause, continue, throttle, or kill a given process.

Dependency:
  cputhrottle
    http://www.willnolan.com/cputhrottle/cputhrottle.html
EOM
process() {
  local _name=
  local _pid=
  local _subcommand=
  local _arguments=()
  local _throttle_percent=
  for arg in "${_COMMAND_ARGV[@]:-}"
  do
    case $arg in
      -n|--name)
        shift
        _name="$arg"
        ;;
      pause|continue|throttle|kill)
        _subcommand="$arg"
        ;;
      *)
        _arguments+=($arg)
        ;;
    esac
  done

  if [[ -z "$_name" ]]
  then
    _pid="${_arguments[1]:-}"
    _debug printf "process() \$_pid: %s\n" "$_pid"
  else
    _die printf "Process id missing.\n"
  fi

  case "$_subcommand" in
    "pause")
      if [[ -n "$_name" ]]
      then
        killall -STOP -c "$_name"
      else
        kill -STOP "$_pid"
      fi
      ;;
    "continue")
      if [[ -n "$_name" ]]
      then
        killall -CONT -c "$_name"
      else
        kill -CONT "$_pid"
      fi
      ;;
    "throttle")
      if ! _command_exists "cputhrottle"
      then
        _die printf "\
cputhrottle not installed.

Get it from here:
  http://www.willnolan.com/cputhrottle/cputhrottle.html
"
      fi
      cputhrottle "$_pid" "${_arguments[2]:-}"
      ;;
    "kill")
      if [[ -n "$_name" ]]
      then
        killall -c "$_name"
      else
        kill "$_pid"
      fi
      ;;
    *)
      $_ME help process
      ;;
  esac
}

# ------------------------------------------------------------------ Quick Look

desc ql <<EOM
Usage:
  $_ME ql <item>

Description:
  Open items with Quick Look.
EOM
ql() {
  qlmanage -p "$*" > /dev/null 2>&1
}

# ----------------------------------------------------------------------- Sleep

desc sleep <<EOM
Usage:
  $_ME sleep

Description:
  Put the system to sleep immediately.
EOM
sleep() {
  pmset sleepnow
}

# -------------------------------------------------------------- softwareupdate

desc softwareupdate <<EOM
Usage:
  $_ME softwareupdate ( -l | --list )
  $_ME softwareupdate ( -i | --install ( <item> | ( -a | --all ) ) )

Options:
  -l --list    List available updates
  -i --install Install the given update or all of the available updates.
    -a --all   When used with -i or --install, install all available updates.

Description:
  Get and install updates available through Apple's software update catalog,
  or whichever .sucatalog is set in preferences for catalogs provided by OS X
  Server's Software Update service.

  This is just a redundant wrapper around the \`softwareupdate\` utility
  included as a bookmark. See \`man softwareupdate\` for more options.
EOM
_SOFTWAREUPDATE_COMMAND="$(which softwareupdate)"
softwareupdate() {
  "$_SOFTWAREUPDATE_COMMAND" "${@:-}"
}

# ------------------------------------------------------------------- Spotlight

desc spotlight <<EOM
Usage:
  spotlight find      <filename>
  spotlight filename  <filename>
  spotlight content   <text>
  spotlight disable
  spotlight enable

Description:
  Spotlight searching and controls.
EOM
spotlight() {
  case "$1" in
    filename|find)
      shift
      mdfind "kMDItemDisplayName == '$*'wc"
      ;;
    content)
      shift
      mdfind -interpret "$*"
      ;;
    disable)
      sudo mdutil -a -i off
      ;;
    enable)
      sudo mdutil -a -i on
      ;;
    *)
      _print_desc "spotlight"
      ;;
  esac
}

desc sl <<EOM
Description:
  Spotlight searching and controls. This is an alias for the \`spotlight\`
  command. See \`help spotlight\` for usage information.
EOM
sl() {
  $_ME spotlight "$@"
}

# ------------------------------------------------------------------------ sshd

desc sshd <<EOM
Usage:
  $_ME sshd ( start | stop | status )

Description:
  Start, stop, or get the status of sshd for remote login.
EOM
sshd() {
  local _action="$1"
  if [[ "$_action" == "start" ]]
  then
    sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
    sshd status
  elif [[ "$_action" == "stop" ]]
  then
    sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist
    sshd status
  elif [[ "$_action" == "status" ]]
  then
    local _results="$(sudo launchctl list | grep com.openssh.sshd)"
    [[ -n "$_results" ]] && printf "sshd running\n" || printf "sshd stopped\n"
  else
    _die printf "Command not recognized.\n%s\n" "$(_print_desc "sshd")"
  fi
}

# ----------------------------------------------------------------------- stats

desc stats <<EOM
Usage:
  $_ME stats

Description:
  Display temperature, fan, and battery status via the iStats Ruby gem.

  More information:
    https://github.com/Chris911/iStats
EOM
stats() {
  if _command_exists "istats"
  then
    istats
  else
    _die printf "\
iStats not installed.

Install via Rubygems with:
  gem install iStats

More information:
  https://github.com/Chris911/iStats
"
  fi
}

# ---------------------------------------------------------------------- sysctl

desc sysctl <<EOM
Usage:
  $_ME sysctl <arguments>

Description:
  Configuration tool for certain machine settings in System Preferences.

  This is simply a bookmark for the system's sysctl utility.

  See \`man sysctl\` for more information.

Examples:
  sysctl -n machdep.cpu.brand_string
    Print CPU information.

  sysctl vm.loadavg
    Print load average history.
EOM
_SYSCTL_CMD="$(which sysctl)"
sysctl() {
  "$_SYSCTL_CMD" "$*"
}

# ----------------------------------------------------------------- systemsetup

desc systemsetup <<EOM
Usage:
  $_ME systemsetup <arguments>

Description:
  Configuration tool for certain machine settings in System Preferences.

  This is simply a bookmark for the system's systemsetup utility.

  See \`man systemsetup\` for more information.

Examples:
  systemsetup -setdate 04:15:02

  systemsetup -settime 16:20:00

  systemsetup -settimezone US/Pacific

  systemsetup -setnetworktimeserver time.apple.com
EOM
_SYSTEMSETUP_CMD="$(which systemsetup)"
systemsetup() {
  "$_SYSTEMSETUP_CMD" "$*"
}

# ------------------------------------------------------------------------ temp

desc temp <<EOM
Usage:
  $_ME temp

Description:
  Display CPU and battery temperature via the iStats Ruby gem.

  More information:
    https://github.com/Chris911/iStats
EOM
temp() {
  if _command_exists "istats"
  then
    istats cpu
    istats battery temp
  else
    _die printf "\
iStats not installed.

Install via Rubygems with:
  gem install iStats

More information:
  https://github.com/Chris911/iStats
"
  fi
}
desc temperature <<EOM
Usage:
  $_ME temperature

Description:
  Alias for \`temp\`.

  Display CPU temperature via the iStats Ruby gem.

  More information:
    https://github.com/Chris911/iStats
EOM
temperature() {
  $_ME temp
}


# -------------------------------------------------------------------- textutil

desc textutil <<EOM
Usage:
  $_ME textutil [command_option] [other_options] file...

Description:
  textutil can be used to manipulate text files of various formats, using the
  mechanisms provided by the Cocoa text system.

  This is simply a bookmark for the system's textutil utility.

  See \`man textutil\` for more information.

Examples:
  textutil -convert html MyWordFile -output /tmp/webfile.html
    Convert a Word document into HTML.

  textutil -info MyWordFile
    Display information about the file format.
EOM
_TEXTUTIL_CMD="$(which textutil)"
textutil() {
  "$_TEXTUTIL_CMD" "$*"
}

# ----------------------------------------------------------------------- Trash

desc trash <<EOM
Usage:
$_ME trash ( empty [--secure] [--all] | open )

Subcommands:
  empty  Empty the trash.
  open   Open the trash folder in the finder.

Options:
  --secure  Use \`srm\` to securely delete trash contents.
  --all     Empty trashes on all connected volumes.
EOM
trash() {
  local _subcommand=
  local _secure=
  local _all=
  for arg in "${_COMMAND_ARGV[@]:-}"
  do
    case "$arg" in
      empty|open)
        _subcommand="$arg"
        ;;
      --secure)
        _secure=1
        ;;
      --all)
        _all=1
        ;;
      *)
        :
        ;;
    esac
  done

  case "$_subcommand" in
    "open")
      open "$HOME/.Trash"
      ;;
    "empty")
      local _trash_command="rm -rfv"
      if [[ -n "$_secure" ]]
      then
        _trash_command="srm -rfvm"
      fi

      sudo "$_trash_command" ~/.Trash/
      if [[ -n "$_all" ]]
      then
        sudo "$_trash_command" /Volumes/*/.Trashes
      fi
      ;;
    *)
      _print_desc "trash"
      ;;
  esac
}

# ------------------------------------------------------------------------- vnc

desc vnc <<EOM
Usage:
  $_ME vnc ( start | stop | status )

Description:
  Start, stop, or get the status of vnc aka Screen Sharing aka Remote Desktop.
EOM
vnc() {
  local _action="$1"
  # Start and stop commands via: http://apple.stackexchange.com/q/30238
  if [[ "$_action" == "start" ]]
  then
    sudo /System/Library/CoreServices/RemoteManagement/ARDAgent.app/Contents/Resources/kickstart \
      -activate \
      -configure \
      -access \
      -on \
      -configure \
      -allowAccessFor \
      -allUsers \
      -configure \
      -restart \
      -agent \
      -privs \
      -all
  elif [[ "$_action" == "stop" ]]
  then
    sudo /System/Library/CoreServices/RemoteManagement/ARDAgent.app/Contents/Resources/kickstart \
      -deactivate \
      -configure \
      -access \
      -off
  elif [[ "$_action" == "status" ]]
  then
    local _results="$(pgrep ARDAgent)"
    [[ -n "$_results" ]] && printf "vnc running\n" || printf "vnc stopped\n"
  else
    _die printf "Command not recognized.\n%s\n" "$(_print_desc "vnc")"
  fi
}

# ---------------------------------------------------------------- WindowServer

desc windowserver <<EOM
Usage:
  $_ME windowserver kill

Description:
  Kill WindowServer. Warning: this will quit all running applications and log
  out of the current user account.

  Killing WindowServer and be used to reset the UI of OS X, esspecially if it
  slows down over a period of use as the process becomes bloated.
EOM
windowserver() {
  if [[ "$1" == "kill" ]]
  then
    local _kill_windowserver
    while true
    do
      read -p "Are you sure you want to close all apps and log out? [y/n] " yn
      case $yn in
        [Yy]* )
          _kill_windowserver=1
          break
          ;;
        [Nn]* )
          _kill_windowserver=0
          break
          ;;
        * )
          printf "Please answer yes or no.\n"
          ;;
      esac
    done
    if ((_kill_windowserver))
    then
      printf "Logging out...\n"
      # via: http://hints.macworld.com/article.php?story=20071121154033749
      sudo killall -HUP WindowServer
    else
      printf "Exiting...\n"
      exit
    fi
  else
    _print_desc "windowserver"
  fi
}

###############################################################################
# Platform Check
###############################################################################

if [[ ! "$OSTYPE" =~ ^darwin ]]
then
  printf "osx-cli is only supported on OS X.\nExiting...\n"
  exit 0
fi

###############################################################################
# Run Program
###############################################################################

# Calling the _main function after everything has been defined.
_main

